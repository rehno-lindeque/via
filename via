#!/usr/bin/env bash

set -euo pipefail

BASE_DEFAULT="/run/via"
BASE="${REPLS_DIR:-$BASE_DEFAULT}"

die() { echo "via: $*" >&2; exit 1; }
need() { command -v "$1" >/dev/null 2>&1 || die "missing dependency: $1"; }

ensure_base() {
  if [[ ! -d "$BASE" ]]; then
    mkdir -p "$BASE" 2>/dev/null || {
      BASE="${XDG_RUNTIME_DIR:-/tmp}/via"
      mkdir -p "$BASE" || die "can't create $BASE"
    }
  fi
}

list_sessions() {
  ensure_base
  find "$BASE" -mindepth 1 -maxdepth 1 -type d -printf "%f\n" 2>/dev/null | sort
}

start_session() {
  local session="$1"; shift || true
  # Remaining args are the command line, expecting a leading "--"
  [[ $# -ge 2 && "$1" == "--" ]] || die "usage: via ${session} run -- <command> [args...]"
  shift # consume --
  local dir="$BASE/$session"
  mkdir -p "$dir"

  local in="$dir/stdin" out="$dir/stdout"

  echo "[via] dir: $dir"
  echo "[via] stdin: $in"
  echo "[via] stdout: $out"
  echo "[via] launching: $*"

  # remove the directory when teetty exits (normal exit or signal)
  trap "rm -rf '$dir' 2>/dev/null || true" EXIT INT TERM HUP

  # foreground; you keep interactive control here
  teetty -i "$in" -o "$out" --truncate -- "$@"
}

write_session() {
  local session="$1"; shift || true
  ensure_base
  local in="$BASE/$session/stdin"
  [[ -e "$in" ]] || die "no stdin at $in (is the session running?)"

  if [[ $# -gt 0 ]]; then
    printf "%s\n" "$*" >>"$in"
  else
    cat >>"$in"
  fi
}

# Tail helper supporting combinations:
#   -n N                     (controls window size, default 100)
#   --since PROMPT           (last lines since the most recent prompt)
#   --delim PROMPT           (stanza since the most recent prompt)
# You may combine -n with either --since or --delim.

tail_stanza() {
  local session="$1"; shift || true
  ensure_base
  local out="$BASE/$session/stdout"
  [[ -r "$out" ]] || die "no stdout at $out"

  local n="" mode="" prompt=""

  # Parse flags (allow -n combined with one of --since/--delim)
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n)
        [[ -n "${2:-}" ]] || die "usage: via ${session} tail -n <N> [--since PROMPT|--delim PROMPT]"
        n="${2}"
        shift 2
        ;;
      --since)
        [[ -n "${2:-}" ]] || die "usage: via ${session} tail --since PROMPT"
        [[ -z "$mode" ]] || die "only one of --since/--delim allowed"
        mode="since"; prompt="${2}"; shift 2
        ;;
      --delim)
        [[ -n "${2:-}" ]] || die "usage: via ${session} tail --delim PROMPT"
        [[ -z "$mode" ]] || die "only one of --since/--delim allowed"
        mode="delim"; prompt="${2}"; shift 2
        ;;
      *)
        break
        ;;
    esac
  done

  # Determine window size
  local window
  if [[ -n "$n" ]]; then
    window="$n"
  else
    window=100
  fi

  # Execute
  if [[ -z "$mode" ]]; then
    # Plain tail requires -n
    [[ -n "$n" ]] || die "usage: via <session> tail [-n N] (--since PROMPT | --delim PROMPT)"
    tail -n "$n" "$out"
    return 0
  fi

  if [[ "$mode" == "since" ]]; then
    tail -n "${window}" "$out" \
      | tac \
      | grep -m 1 -B "${window}" -F "$prompt" \
      | tac
  else
    tail -n "${window}" "$out" \
      | tac \
      | grep -m 2 -B "${window}" -F "$prompt" \
      | sed -n "/$prompt/,\$p" \
      | tac
  fi
}

show_usage_global() {
  cat <<EOF
usage:
  via                                   # list sessions
  via help                              # this help
  via <session> help                    # help for a specific session name
  via <session> run -- <cmd> ...        # start <name> session (interactive)
  via <session> write [line...]         # write (reads stdin if none)
  via <session> tail -n N               # tail last N lines
  via <session> tail --since 'PROMPT>'  # tail since last PROMPT>
  via <session> tail --delim 'PROMPT>'  # last stanza since PROMPT>
  via <session> path                    # show session path

shorthand usage:
  via <session> 'PROMPT>' [line...]     # write input and read output in one command
EOF
}

show_session_usage() {
  local session="$1"
  cat <<EOF
usage for '${session}':
  via ${session} help                    # help for a specific session session
  via ${session} write [line...]         # write (reads stdin if none)
  via ${session} tail -n N               # tail last N lines
  via ${session} tail --since 'PROMPT>'  # tail since last PROMPT>
  via ${session} tail --delim 'PROMPT>'  # last stanza since PROMPT>
  via ${session} path                    # show session path

shorthand usage:
  via ${session} 'PROMPT>' [line...]     # write input and read output in one command
EOF
}

path_of() { ensure_base; echo "$BASE/$1"; }

need teetty
need tail
need grep
need sed
need tac
ensure_base

case "${1:-}" in
  "" )
    list_sessions
    ;;
  help|-h|--help )
    show_usage_global
    ;;
  * )
    session="$1"; shift || true
    subcmd="${1:-}"
    case "${subcmd:-}" in
      help|-h|--help )
        show_session_usage "$session"
        ;;
      run )
        shift || true
        start_session "$session" "$@"
        ;;
      write )
        shift || true
        write_session "$session" "$@"
        ;;
      tail )
        shift || true
        tail_stanza "$session" "$@"
        ;;
      path )
        shift || true
        path_of "$session"
        ;;
      "" )
        die "missing subcommand for '$session' (try: via ${session} help)"
        ;;
      * )
        # Shorthand: if the first token ends with '>', treat it as PROMPT>
        if [[ "$subcmd" == *\> ]]; then
          prompt="$subcmd"; shift || true
          # If there are remaining args, write them as a single line.
          # Otherwise, read from stdin and forward to the REPL.
          if [[ $# -gt 0 ]]; then
            write_session "$session" "$*"
          else
            write_session "$session"
          fi
          tail_stanza "$session" --delim "$prompt"
        else
          die "unknown subcommand for '$session': $subcmd (try: via ${session} help)"
        fi
        ;;
    esac
    ;;
esac
